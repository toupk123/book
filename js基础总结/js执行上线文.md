# js执行上下文  

 &nbsp;&nbsp;&nbsp;执行上下文是当前js代码被解析和执行的地方.执行上下文是在函数调用时才会进行创建，比如一个函数只是在进行声明，那么函数本身并不会创建一个新的执行上下文。  

执行上下文分以下三类：  

1. 全局执行环境，只有一个，浏览器中的全局对象就是window对象.  

2. 函数执行环境，存在无数个，只有在调用才会被创建，并推入执行栈中  

3. eval函数，建议不使用，所以不做介绍。  

## 执行栈  

 &nbsp;&nbsp;&nbsp;执行栈也就是调用栈，先进后出结构。用于来存储代码运行时期，创建的所有执行上下文。在初次运行时，会创建一个全局执行文在底部。
 
    从这里也可以看出来，js语言是基于一个全局环境执行编译执行,这也就是为什么我们能够在所有的函数里面，都能拿到window或global对象的原因。 

### 执行文创建  

1. 确定this的值。(也就是说this的值是在函数执行，创建上下文才确定，函数声明时没有确定this值。ps:箭头函数除外)  

2. 词法环境组件被创建  

3. 变量环境组件被创建  

#### 词法环境  

词法环境分为两个部分  

1. 环境记录：存储变量和函数声明的实际位置  

2. 对外部环境的引用：可以访问外部词法环境（可以说这也就是闭包产生的原因）  

同时词法环境是分为两类 

1. 一类是全局环境，全局环境自然是没有外部环境的引用，这个值是为null。环境记录存在一个唯一的全局对象，以及用户自定义创建的全局变量。  
2. 二类函数环境：和全局环境类似，但是存在对外部环境引用，也就是为什么可以使用外部变量的原因。  

#### 变量环境  

变量环境其实也就是一个词法环境，具有上述所有的属性，区别就在于在es6中，**词法环境储存函数声明和变量（let const）声明**,而变量环境 **只是用于储存（var）变量绑定**  


#### 变量提升  

    所以在这里也就可以解释一下，为什么会存在变量提升。变量var 通过变量声明，是存储在变量环境之中，在创建变量组件环境时就已经将这些变量的值设定为undefind，也就是变量已经被声明。但是通过let和const在没有实际调用时，let声明都是被设定为一个无法使用的值  

#### 执行阶段  

1. 函数被调用 
2. 函数被推入调用栈中 
3. 该函数执行上下文被执行，执行文控制权移入 
4. this值确定，词法环境 变量环境确定，一切声明变量确定 &nbsp;
5. 代码正式运行，运行到相应的代码进行赋值。  

##### 注意点  

1. js是一门带线程语言，执行顺序肯定肯定就是顺序执行，但是js并不是一行代码一行代码执行，而是一片代码一片代码执行。也就是先编译再执行。  

2. 下面代码可以说明，声明优先级是函数>变量  

 ```javaScript  
 var function1 =  function(){  
   console.log(2)  
 }  
 function1() // 1  
 function1(){  
   console.log(1)  
 }  
 ```  

#### js内存  

js是依靠执行栈本身是具有内存大小限制，当调用函数超过堆栈最大调用数，浏览器就会进行报错，这也就是浏览器中js不能进行大数据计算的原因。  

栈数据结构，是先进后退的数据结构  
堆数据结构，是一种数字图结构，只有关心存取，通过key-value  
队列结构。是一种先进先出，这也就是事件循环的基础结构。（后面详情记录）  

#### 变量的存放  

1. 基础类型，保存在栈内存中，这些类型分别沾有固定的大小空间，通过按值访问。基本类型一共有6种：undefined null boolean number symbol（不包含闭包中的变量）  

2. 引用类型。存放在堆内存中，这类数据大小空间不确定。栈内存中只存放该对象的访问地址，实际对象存放在堆内存中。  

在计算机的数据结构中，栈的运算速度是没有堆快，而且栈的内存空间远没有堆大。  

#### 内存空间管理  

js有自动垃圾回收机制，一般最常用就是标记清除的算法来找到哪些对象是不再继续使用的，一旦变量值没有被任何一个变量使用时，下一次垃圾收集器就会清理掉堆内存中的变量（一般栈内存的变量，在函数退出栈后，这些值就会被清理掉。）  

##### 闭包中栈变量  

闭包中执行栈中的基础类型变量，其实是保存在堆内存中，这也就解释了，为啥对应的函数已经离开执行栈，但是这些变量值还被保存(关于js的垃圾回收，后面再进行讲解).  
