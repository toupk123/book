# 关于EventLoop的问题

在浏览器环境中，通过事件等触发的事件，并且需要处理的异步任务，任务队列中，浏览器主线程一旦执行完毕，就会循环这个任务队列，

### JS运行机制

js 分为同步任务和异步任务。同步任务在主线程上面执行，形成一个执行栈。
主线程之外，*事件触发线程*管理着一个任务队列，只要异步任务有结果，就会将事件推入任务队列中。

*一旦主线程执行栈中的任务执行完毕*,js引擎就会去执行任务队列中的事件，。如此反复。

#### 定时器

调用setTimeout或者setInterval时，其实是*定时器线程在时间到达后*,便将将事件推入任务队列中。

#### 宏任务与微任务

宏任务：可以理解为每次执行栈执行的代码，就是一个宏任务。
每一个宏任务会从头到尾执行完毕，不会执行其他，浏览器为了能够是js内部的任务和dom能够有序执行，一般会在一个宏任务执行完毕后，就会渲染页面

//宏任务 -> 渲染 -> 宏任务

微任务：可以理解为当前宏任务执行完毕之后，下一个宏任务执行之前，渲染之前，执行的函数

// 宏任务 -> 微任务 -> 渲染 -> 宏任务

macrotask：一般是指主代码快，setTimeout （几乎每一个事件都是一个task）

microtask:Promise process.nextTick.

宏任务中的事件都是放在一个事件队列中的，这个是由事件触发线程维护，
但是所有的微任务都是放在微任务队列中，等待当前宏任务事件执行完毕，这个队列是由js引擎线程维护的。

1. 执行一个宏任务（如果执行栈中没有事件，就从事件队列中获取）

2. 如果执行过程中，遇到了微任务就将他放置到微任务队列中。

3. 宏任务执行完毕后，就会立即执行微任务队列中的所有任务

4. 当前宏任务执行完毕，微任务执行完毕后，开始渲染，然后gui开始渲染

5. 这渲染完毕后，js接着渲染，开始下一个宏任务。

*并不是所有浏览器都支持promise（IE）* ，这些不支持promise的浏览器，自然也就没有微任务这一说，基本都是靠setTimeout模拟执行

常见的宏任务：

1. 渲染事件
2. 用户交互事件
3. js脚本执行
4. 网络请求 文件读写完成事件等等

常见的微任务：



