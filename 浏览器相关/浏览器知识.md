# 浏览器

## 浏览器的多进程架构

### 首先谈谈进程和线程

一个程序运用可能会有多个进程,系统会为一个进程分配一个内存空间，应用会将一些状态保存在这个进程里面，进程互相之间可以进行通讯，但是一个线程关掉，并不会导致整个程序崩溃。

浏览器也就是多进程模式，但是在拥有一个顶层进程，协调浏览器的其他进程。

顶层进程 Browser

渲染进程（render进程），则是浏览器中一个页面的进程，含有

GUI线程

JS引擎线程

事件触发线程

定时器线程

网络请求线程

一个进程相当于一个工厂，工厂之间相互独立，进程就相当于一个工厂的工人，工人之间可以相互交流

## 各线程之间的关系

注意：*GUI渲染线程与js引擎之间的是互斥的*，原因是js引擎可以修改dom元素的信息，如果两个线程运行的话,gui渲染线程在运行，但是js又在进行操作，则会不可意料的错误。所以一个在运行的时候，另一个则会被保存在队列中，等待着空闲运行。

#### JS阻塞页面加载

所以上述的互斥关系就可以明白，如果js长时间的运行的话，那gui渲染线程就会被挂起，那么用户在操作页面的时候，页面就不会出现交互信息

## 渲染进程是如何工作

1. 构建DOM
接受HTML数据，主线程将文本字符串解释成DOM。

2. 加载次级的资源
网页中常常包含诸如图片，css，js

3. js的下载与执行
当遇到`<script>`标签，渲染进程会停止解析HTML，会去加载 解析和执行js代码，因为js可能会修改DOM结构。

4. 样式计算

主线程还会基于css选择器解析css获取每一个节点的最终计算样式值，及时不提供任何css，浏览器也会对每个元素有一个默认的样式。

5. 获取布局

想要渲染一个完整的页面，除开获取每个节点的具体样式，还需要获知每一个节点在页面上的位置，布局就是在找到所有元素的几何关系的过程。

通过遍历DOM及相关元素的计算样式，主线程会构建出包含每个元素的坐标信息

6. 绘制各元素

即便知道了不同元素的位置和样式信息，但是还需要知道不同元素的绘制先后顺序才能正确绘制出整个页面。在绘制阶段，主线程会遍历布局数，来创建绘制记录。

## 从输入url到显示

开启网络线程进行一次请求

1. DNS查询得到IP地址。如果输入域名，就需要先进行查询

如果浏览器有缓存的话，直接使用浏览器中的缓存，否则就是本机上缓存，再没有的话就是host

如果本地没有的话，就会向dns域名服务器查询（当然中间路由器，也会有缓存），查询到IP

2. tcp/ip请求

http本质就是tcp/ip请求

需要了解3次握手规则连接 以及断开连接时的四次挥手。

*tcp/ip的并发限制*
浏览器对同一个域名下并发的tcp链接是由限制的（2-10不等）

在http1.0中往往一个资源下载就需要对应一个tcp ip请求

*get和post区别*

两者虽然从本质上面来说，两者虽然都是tcp/ip ，但还是有区别的。get会产生tcp数据包，get只有一个，但是post会有两个数据包。

具体就是：
get请求时，浏览器会把headers和数据一起请求出来,服务器相应200（返回数据）

post请求时，浏览器先发送headers,服务器响应100， 浏览器再发送data，服务器响应200（返回数据）。

### 解析页面流程

1. 解析HTML，构建DOM树

2. 解析CSS，生成CSS规则树

3. 合并DOM树和CSS规则，生成render树

4. 布局render树（Layout/reflow），负责各元素尺寸、位置的计算

5. 绘制render树（paint），绘制页面像素信息

6. 浏览器会将各层的信息发送给GPU，GPU会将各层合成（composite），显示在屏幕上

其中第四步也就是回流，一般意味着元素的内容 结构 位置 大小发生了变化，需要重写计算样式和渲染树

第五步被称为重绘，表示位置什么的并没有变化，可能只是背景，这个时候只需要应用新样式绘制这个元素就可以了。

所以回流一般的成本开销要高于重绘，并且一个节点的回流往往会导致子节点及同级节点回流。

*什么会引起回流？*

1. 页面初始化渲染

2. dom结构变化，比如删除某个节点。

3. render数变化，比如减少了什么padding,空间变化。

4. 窗口resize

5. 最复杂的一种:获取某些属性，引发回流。

所以回流一定会随着重绘，但是重绘却不一定会导致回流

1. 减少逐项更改样式，最好一次性更改style,或者直接设置class

2. 循环循环操作dom

注意*字体大小会引起回流*

### JS运行机制

js 分为同步任务和异步任务。同步任务在主线程上面执行，形成一个执行栈。
主线程之外，*事件触发线程*管理着一个任务队列，只要异步任务有结果，就会将事件推入任务队列中。

*一旦主线程执行栈中的任务执行完毕*,js引擎就会去执行任务队列中的事件，。如此反复。

#### 定时器

调用setTimeout或者setInterval时，其实是*定时器线程在时间到达后*,便将将事件推入任务队列中。

#### 宏任务与微任务

宏任务：可以理解为每次执行栈执行的代码，就是一个宏任务。
每一个宏任务会从头到尾执行完毕，不会执行其他，浏览器为了能够是js内部的任务和dom能够有序执行，一般会在一个宏任务执行完毕后，就会渲染页面

//宏任务 -> 渲染 -> 宏任务

微任务：可以理解为当前宏任务执行完毕之后，下一个宏任务执行之前，渲染之前，执行的函数

// 宏任务 -> 微任务 -> 渲染 -> 宏任务

macrotask：一般是指主代码快，setTimeout （几乎每一个事件都是一个task）

microtask:Promise process.nextTick.

宏任务中的事件都是放在一个事件队列中的，这个是由事件触发线程维护，
但是所有的微任务都是放在微任务队列中，等待当前宏任务事件执行完毕，这个队列是由js引擎线程维护的。

1. 执行一个宏任务（如果执行栈中没有事件，就从事件队列中获取）

2. 如果执行过程中，遇到了微任务就将他放置到微任务队列中。

3. 宏任务执行完毕后，就会立即执行微任务队列中的所有任务

4. 当前宏任务执行完毕，微任务执行完毕后，开始渲染，然后gui开始渲染

5. 这渲染完毕后，js接着渲染，开始下一个宏任务。

*并不是所有浏览器都支持promise（IE）* ，这些不支持promise的浏览器，自然也就没有微任务这一说，基本都是靠setTimeout模拟执行
